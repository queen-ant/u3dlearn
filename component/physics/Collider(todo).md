碰撞体
======
最简单（并且也是处理器开销最低）的碰撞体是所谓的 _原始_ 碰撞体类型。

在 3D 中，这些碰撞体为**盒型碰撞体、球形碰撞体和胶囊碰撞体**。在 2D 中，可以使用 **2D 盒型碰撞体 和 2D 圆形碰撞体**。**可以将任意数量的上述碰撞体添加到单个对象以创建 _复合碰撞体_ 。**

**可将碰撞体添加到没有刚体组件的对象，从而创建场景的地板、墙壁和其他静止元素。** 这些被称为 __静态__ 碰撞体。通常情况下，不应通过更改变换位置来重新定位静态碰撞体，因为这会极大地影响物理引擎的性能。

_具有_ 刚体的对象上的碰撞体称为 __动态__ 碰撞体。静态碰撞体可与动态碰撞体相互作用，但**由于没有刚体，因此不会通过移动来响应碰撞。**

物理材质
------
物理材质 (Physic Material) 用于**调整碰撞对象的摩擦力和反弹效果**。

当碰撞体相互作用时，它们的表面需要模拟所应代表的材质的属性。例如，一块冰将是光滑的，而橡胶球将提供大量摩擦力并且弹性很好。

虽然碰撞时碰撞体的形状不会变形，但可以使用 __Physics Materials（物理材质）__ 配置碰撞体的摩擦力和弹力。

**请注意，由于历史原因**，3D 资源实际上称为 __Physic Material（物理材质）__ （ _不带_ s），而等效的 2D 资源则称为 __Physics Material 2D（2D 物理材质）__ （ _带_ s）。

要创建物理材质，请从菜单栏中选择 Assets > Create > Physic Material。然后将物理材质从 Project 视图拖入到场景中的 __碰撞体__。

|属性：	|功能：|
| ---- | ---- |
|Dynamic Friction	|已在移动时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将使对象迅速静止（除非用很大的力或重力推动对象）。|
|Static Friction	|当对象静止在表面上时使用的摩擦力。通常为 0 到 1 之间的值。值为零就像冰一样，值为 1 将导致很难让对象移动。|
|Bounciness	|表面的弹性如何？值为 0 将不会反弹。值为 1 将在反弹时不产生任何能量损失，预计会有一些近似值，但可能只会给模拟增加少量能量。|
|Friction Combine	|两个碰撞对象的摩擦力的组合方式。优先级顺序如下： __Average__ < Minimum < Multiply < Maximum。例如，如果一种材质设置了 Average __，但另一种材质设置了 Maximum__，那么要使用的组合函数是 __Maximum__，因为它具有更高的优先级。|
|- Average	|对两个摩擦值求平均值。|
|- Minimum	|使用两个值中的最小值。|
|- Maximum	|使用两个值中的最大值。|
|- Multiply	|两个摩擦值相乘。|
|Bounce Combine	|两个碰撞对象的弹性的组合方式。其模式与 Friction Combine 模式相同|

请注意，Nvidia PhysX 引擎使用的摩擦力模型针对模拟的性能和稳定性进行了调整，**并不一定代表真实物理的高度近似值**。具体而言，大于单个点的接触面（例如两个相互叠放在一起的盒子）将计算为具有两个接触点，其摩擦力将是现实世界物理学中的两倍。在这种情况下，可能希望将摩擦系数乘以 0.5 以获得更真实的结果。

同样的逻辑适用于弹性模型。由于各种模拟细节（如位置校正），Nvidia PhysX **无法保证完美的能量守恒效果**。因此，比如说，如果受重力影响的对象的弹性值为 1，并与弹性为 1 的地面碰撞，则对象的弹跳高度应该会高于初始位置。



碰撞体相互作用
------
碰撞体彼此之间的相互作用根据刚体组件的配置不同而不同。

**三个重要的配置是 _静态碰撞体 (Static Collider)（即完全没有附加任何刚体）、刚体碰撞体 (Rigidbody Collider)_ 和 _运动刚体碰撞体 (Kinematic Rigidbody Collider)_ 。**

静态碰撞体
------
这是一种具有碰撞体但没有刚体的游戏对象。静态碰撞体用于表示关卡几何体，始终停留在同一个地方，永远不会四处移动。**靠近的刚体对象将与静态碰撞体发生碰撞，但不会移动静态碰撞体。**

如果更改静态碰撞体，**则会导致物理引擎进行额外的内部重新计算**，从而导致性能大幅下降。更糟糕的是，这些更改有时会使碰撞体处于不明的状态，从而产生错误的物理计算。

此外，移动的静态碰撞体碰到的刚体不一定会“被唤醒”，**静态碰撞体也不会施加任何摩擦力**。由于这些原因，只应更改刚体碰撞体。

如果希望碰撞体对象不受靠近的刚体影响，但仍然可以通过脚本来移动该对象，**则应为其附加一个 _运动_ 刚体组件附加，而非不附加任何刚体。**

刚体碰撞体
------
这是一种附加了碰撞体和普通非运动刚体的游戏对象。

运动刚体碰撞体
-----

这是一种附加了碰撞体和_运动_刚体（即启用了刚体的 IsKinematic 属性）的游戏对象。

可使用脚本来移动运动刚体对象（通过修改对象的变换组件），**但该对象不会像非运动刚体一样响应碰撞和力**。

**运动刚体应该用于符合以下特征的碰撞体：偶尔可能被移动或禁用/启用，除此之外的行为应该像静态碰撞体一样。**

这方面的一个例子是滑动门，这种门通常用作不可移动的物理障碍物，但必要时可以打开。**与静态碰撞体不同，移动的运动刚体会对其他对象施加摩擦力，并在双方接触时“唤醒”其他刚体。**

**即使处于不动状态，运动刚体碰撞体也会对静态碰撞体产生不同的行为。** 例如，如果将碰撞体设置为触发器，则还需要向其添加刚体以便在脚本中接收触发器事件。如果不希望触发器在重力作用下跌落或在其他方面受物理影响，则可以在其刚体上设置 IsKinematic 属性。

**可使用 IsKinematic 属性随时让刚体组件在正常和运动行为之间切换。** 这方面的一个常见例子是“布娃娃”效果；在这种效果中，角色通常在动画下移动，但在爆炸或猛烈碰撞时被真实抛出。角色的四肢可被赋予自己的刚体组件，并在默认情况下启用 IsKinematic。肢体将通过动画正常移动，直到所有这些肢体关闭 IsKinematic 为止，然后它们立即表现为物理对象。此时，碰撞或爆炸力将使角色飞出，使肢体以令人信服的方式被抛出。

触发器
------
脚本系统可以使用 OnCollisionEnter 函数检测何时发生碰撞并启动操作。但是，也可以直接使用物理引擎检测碰撞体何时进入另一个对象的空间而不会产生碰撞。

**配置为 __触发器__ （使用 IsTrigger 属性）的碰撞体不会表现为实体对象，只会允许其他碰撞体穿过**。当碰撞体进入其空间时，触发器将在触发器对象的脚本上调用 OnTriggerEnter 函数。

脚本碰撞回调
------
发生碰撞时，物理引擎会在附加到相关对象的所有脚本上调用特定名称的函数。可以在这些函数中放置所需的任何代码来响应碰撞事件。例如，当汽车撞到障碍物时，可以播放碰撞音效。

**在第一个检测到碰撞的物理更新中**，将调用 OnCollisionEnter 函数。

**在保持接触的更新期间**，将调用 OnCollisionStay，最后由 OnCollisionExit **指示接触已经中断**。

触发碰撞体会调用模拟的 OnTriggerEnter、OnTriggerStay 和 OnTriggerExit 函数。

请注意，对于 2D 物理，可使用在名称中附加了 2D 字样的等效函数，例如 OnCollisionEnter2D。有关这些函数和代码示例的完整详细信息，请参阅关于 MonoBehaviour 类的脚本参考页面。

对于正常的非触发碰撞，还有一个额外的细节，**即所涉及的对象中至少有一个对象必须具有非运动刚体（即，必须关闭 _IsKinematic_ ）**。**如果两个对象都是运动刚体，则不会调用 OnCollisionEnter 等函数**。**对于触发碰撞，此限制不适用，因此运动和非运动刚体都会在进入触发碰撞体时提示调用 OnTriggerEnter**。

复合碰撞体
------
复合碰撞体是原始碰撞体的组合，共同作为单个刚体。如果模型在性能方面过于复杂或成本过高而无法精确模拟，因此希望使用简单的近似值以最佳方式模拟形状的碰撞，复合碰撞体将派上用场。

**要创建复合碰撞体，请创建碰撞对象的子对象，然后将碰撞体组件添加到每个子对象**。这样就能轻松独立定位、旋转和缩放每个碰撞体。**可以通过许多原始碰撞体和/或凸面网格碰撞体构建复合碰撞体**。

当刚体父对象由于受力而移动时，子碰撞体会随之移动。原始碰撞体将与环境的网格碰撞体碰撞，而父刚体将根据所受的力以及其子碰撞体与场景中其他碰撞体的交互方式来改变自己的移动方式。

网格碰撞体通常不能相互碰撞。如果网格碰撞体被标记为 __凸面体 (Convex)__ ，则可与另一个网格碰撞体发生碰撞。**典型的解决方案是对所有移动的对象使用原始碰撞体，而对静态背景对象使用网格碰撞体**。

**注意：使用碰撞回调时，复合碰撞体会为每个碰撞体碰撞对返回单独的回调**。

碰撞矩阵
-----
**Unity的物理管理器提供了多种数据配置，可以设置层碰撞矩阵**。

Broad-Phase
-----
https://zhuanlan.zhihu.com/p/113415779

### 碰撞检测的流程
显然直接两两检测的复杂度是O(n^2)，所以要采取优化方案。分成两个部分，Broad-Phase、Narrow-Phase

Broad-Phase使用某种Bounding Volume来表示刚体的碰撞信息,然后用空间划分的方式来保存这些Bounding Volume,就**可以在较短的时间内筛选出可能互相碰撞的刚体对.**

Narrow-Phase就是将这些刚体对进行真正的碰撞检测.

### 简化碰撞边框

使用Bounding Volume（包围体），常用的有AABB(axis-aligned bounding boxes)轴对齐包围盒, OBB(oriented bounding boxes)有向包围盒, Circle/Sphere。

AABB性能最好，只需判断两个AABB在每个轴上是否都有重叠部分。表示一个AABB信息，只需要保存最大点（右上角）和最小点（左下角）

### 空间分割

- Sort and Sweep

也叫Sweep and Prune,在每个轴上,将AABB表示为一个间隔 [b,e] ,表示开始点和结束点,然后都放都一个列表中进行排序.

在所有三个轴上都有重叠的AABB就是有重叠的AABB对.

实际的碰撞检测中,不需要每帧都对所有点都进行排序,只需要在初始化时进行排序,只需将需要更新的AABB重新执行插入排序即可

在三维的碰撞检测时,使用这种方法容易遇到在某个轴上聚集的问题,这种情况下,可以考虑舍弃一个轴的检测.

- Uniform Grid

Uniform Grid就是将空间划分成等大小的格子,若AABB于某个格子有相交,将该AABB保存在这个格子上.在某个格子上有多个AABB时,将这些AABB进行相交测试.

考虑到实际运行时很多格子是空着的,通常存储Grid时,会采用哈希的方法,将格子映射到哈希表中

对于Uniform Grid,选择一个合适的格子大小至关重要,太大和太小都会导致性能下降.

合适的格子大小应该是跟碰撞体大小接近.如果碰撞体的大小本身就差异很大,则很难选择一个合适的大小.

Hierarchical Grids 是一种对Uniform Grid的改进,用来处理碰撞体大小差异很大的情况,其实就是将很多个不同大小格子的Grid放在一起,这样每个碰撞体都能找到一个适合自己大小的Grid,和Octree很相似.

- Bounding Volume Hierarchical(BVH)

简单来说,BVH就是将BV用树的方式组织在一起,每个父节点是所有子节点BV的合并,并尽量保持每个节点的BV最小.

BVH可以非常方便地进行碰撞求交,射线求交.只需要从根节点开始逐渐向下遍历,就可以轻松得到结果.

BVH的一个很强大的优点是,构建完成后不仅可以用来做碰撞检测,**同时可以用来做视锥裁剪,遮挡裁剪,光线追踪等操作.**

BVH的构建方式有很多中,来看下主要的几种:

1.top-down : 离线渲染中最流行的方法.将所有BV放在一起组成树的根节点,使用合适的方式将根节点分割成两部分组成子节点,这样递归式地循环往下分割,构成完整的BVH.

选择分割轴和分割点的方式多种多样,比如最简单的一种方式是从XYZ轴选取一个最长的轴作为分割轴,选取所有BV中心点的平均中心作为分割点.

top-down方法的一个优势是可以实现懒初始化,整个BVH在真正需要用到的时候再初始化.但是也因为其构建时间较长,导致其在实时渲染等对帧率有要求的地方应用不多.

2.bottom-up: 和top-down方法正好相反,逐渐将BV节点合并,从下往上构建BVH.通常比top-down的计算方式更复杂,效果会较好,耗时也更长.

3.incremental tree-insertion: 从一个空的树开始,将BV逐个插入到树中,使用一些类似AVL树的方式自平衡,最后构建出一个BVH.

算法的关键是寻找一个合适的插入点.一个简单的方法是选取使的树的变化最小的位置,通常这类算法的时间复杂度是O(nlogn) . 随机化BV输入的顺序,也可以提高树的规整性.

4.linear BVH: 一种面向GPU编程设计的BVH,在CPU上也有不错的性能.核心思想是将整体空间划分为网格,计算刚体中心点在的格子位置,然后用Morton Code来代指格子的位置.然后将所有刚体按照Morton Code进行排序.最终用排序好的刚体分层式地构建出BVH.

- Binary Space Partitioning(BSP) trees
不同于BVH的递归式分组,BSP是递归式划分空间.通过递归式地寻找合适的轴将空间划分,自上而下构建出一颗树.主要有两种形式:

1.Axis-Aligned BSP Trees (k-D Trees)

先确定最大的长方体,然后递归寻找合适的轴来划分成两个长方体.寻找分割轴和分割点的方式,和使用top-down来构建BVH的方式基本是类似的.

至于和分割平面相交的几何体,有多种方式处理.可以将几何体放到父节点上,也可以在子节点各放一个,也可以将几何体切分.每种方式都有一些优缺点.

2.Polygon-Aligned BSP Trees

和k-d Tree的区别在于分割轴不一定是平行于坐标轴的,整体复杂度也更高.

3.Octree/Quadtree

Octree可以看成是Axis-Aligned BSP Tree的一种特殊情况,每次划分平面都是过空间中心的XYZ轴.使用起来基本上是一样的,相对来说省去了选择分割轴的分割点的工作,较简单一点.

Octree会造成很多几何体和分割轴相交,难以处理.一种改进方式是loose octree,将每个分割的正方体实际范围扩大x1.5,这样即使和分割轴相交,也必定可以放到某个子节点内.

BVH的动态更新也会用到这种思想,把AABB进行略微放大,这样就不用在每次移动时都重新执行一次插入操作.

Grid,BVH,BSP,Octree这些空间组织数据结构,不仅用在Broad-Phase碰撞检测,在Occlusion Culling,Ray tracing等方面也有相当广泛的应用.

Narrow-Phase
-----
https://zhuanlan.zhihu.com/p/127844705
### 碰撞检测

- Separating Axis Theorem(SAT)算法

SAT的原理:两个凸多边形不相交,当且仅当必然存在一条直线,两个凸多边形在这条直线上的投影不相交.或者描述为:两个凸多边形相交,则在所有直线上的投影都是相交的. 对于凸多面体也是一样的,只是投影在面上.

SAT算法的一个缺点,就是只能适用于多边形/多面体,不能直接适用圆形/球形的物体.

box2d中多边形之间的碰撞通过SAT算法来实现.

- Gilbert-Johnson-Keerthi (GJK)算法

chipmonk,bullet,physx中的碰撞都是通过GJK实现,box2d的CCD和部分碰撞检测也是通过GJK实现的,GJK是物理引擎中计算碰撞的主流方案

- Expanding Polytope Algorithm(EPA)

上面的GJK算法,我们算出了当两个物体不相交时的最近距离.当两个几何体相交时,GJK算法会终止退出.而在处理碰撞的时候,我们不仅要知道两个几何体是否相交,还要知道相交的穿透深度(penetration depth).当GJK的算法退出后,我们在GJK得到的单纯形的基础上使用EPA算法,就可以算出两个几何体的穿透深度.

### Continuous Collision Detection(CCD)

实际的物理引擎运行中,运动速度很快微小的物体可能出现无法计算到碰撞的隧穿(tunneling)情况.CCD尝试找到两个本来应该碰撞的几何体的碰撞时间time of impact(TOI),并回到那个时间点处理碰撞.

### Collision Response 碰撞反馈

碰撞反馈是一个非常复杂的问题，实际物理引擎中的碰撞，常作为一个约束来求解。

约束
-----
https://zhuanlan.zhihu.com/p/143003234

射线（Raycast）
-----
