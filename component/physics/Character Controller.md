角色控制器（CharacterController）
=======
角色控制器 (Character Controller) 主要用于第三人称玩家控制或者是不使用 __刚体__ 物理组件的第一人称玩家控制。

属性
------
|属性：	|功能：|
|----|----|
|slopeLimit	|将碰撞体限制为爬坡的斜率不超过指示值（以度为单位）。|
|StepOffset	|仅当角色比指示值更接近地面时，角色才会升高一个台阶。该值不应该大于角色控制器的高度，否则会产生错误。|
|skinWidth	|两个碰撞体可以穿透彼此且穿透深度最多为皮肤宽度 (Skin Width)。较大的皮肤宽度可减少抖动。较小的皮肤宽度可能导致角色卡住。合理设置是将此值设为半径的 10%。|
|minMoveDistance	|如果角色试图移动到指示值以下，根本移动不了。此设置可以用来减少抖动。在大多数情况下，此值应保留为 0。|
|center	|此设置将使胶囊碰撞体在世界空间中偏移，并且不会影响角色的枢转方式。|
|radius	|胶囊碰撞体的半径长度。此值本质上是碰撞体的宽度。|
|height	|角色的__胶囊碰撞体__高度。更改此设置将在正方向和负方向沿 Y 轴缩放碰撞体。|
|isGrounded	|在上次移动期间 CharacterController 是否接触地面|
|velocity	|该角色的当前相对速度（请参阅注释）。|
|collisionFlags	|在上次 CharacterController.Move 调用期间，该胶囊体的哪个部分与环境发生了碰撞。|
|detectCollisions	|确定其他刚体或角色控制器是否与该角色控制器碰撞（默认情况下始终启用它）。|
|enableOverlapRecovery	|启用或禁用重叠恢复。 启用或禁用重叠恢复。用于在检测到重叠时取消角色控制器从静态对象的穿透。|

公共函数
------
|||
|-----|----|
|Move	|采用绝对移动增量的更复杂移动函数。|
|SimpleMove	|以 speed 移动该角色。|

消息
-----
|||
|-----|----|
|OnControllerColliderHit	|当该控制器在执行 Move 时撞到碰撞体时调用 OnControllerColliderHit。|


详细信息
------
角色控制器只是一个胶囊形状的 __碰撞体__ ，可以通过脚本来命令这个碰撞体向某个方向移动。然后，控制器将执行运动，但会受到碰撞的约束。控制器将沿着墙壁滑动，走上楼梯（如果低于 Step Offset 值），并走上 Slope Limit 设置范围内的斜坡。

**控制器本身不会对力作出反应，也不会自动推开刚体**。

**如果要通过角色控制器来推动刚体或对象，可以编写脚本通过 OnControllerColliderHit() 函数对与控制器碰撞的任何对象施力**。

另一方面，如果希望玩家角色受到物理组件的影响，那么可能更适合使用刚体，而不是角色控制器。

微调角色
------
可以修改 Height 和 Radius 属性来适应角色的网格。对于人形角色，**建议始终使用 2 米左右的高度**。如果轴心点并非刚好在角色的中心，还可以修改胶囊体的 Center 属性。

Step Offset 属性也可能有影响，对于身高 2 米的人，**请确保此值在 0.1 到 0.4 之间**。

Slope Limit **不应太小。通常，使用 90 度的值效果最佳**。由于胶囊体形状的原因，角色控制器将无法爬墙。

不要被卡住
-------
要正确调整角色控制器， __Skin Width__  属性是最重要的属性之一。 **如果角色被卡住，那么很可能是因为 Skin Width 设置过小**。Skin Width 允许对象轻微穿透控制器，但可消除抖动并防止被卡住。

**最好是让 Skin Width 的值至少大于 0.01 并且比 Radius 的值大 10%**。

**建议将 Min Move Distance 保持为 0**。

Tips
-----
- 如果发现角色经常被卡住，请尝试调整 Skin Width。
- 如果是自己编写脚本，则角色控制器可能会影响使用物理组件的对象。
- 对象无法通过物理组件来影响角色控制器。
- 请注意，在 Inspector 中更改角色控制器属性将在场景中重新创建控制器，因此任何现有的触发器触点都将丢失，并且在再次移动控制器之前，不会收到任何 OnTriggerEntered 消息。
- 在查询中使用的角色控制器胶囊体（比如射线投射）可能会略有缩小。因此，在某些极端情况下，即使查询似乎命中了角色控制器的辅助图标，但实际可能未命中。

输入（Input）
-----
使用 Input 设置（顶部菜单：Edit > Project Settings，然后选择 Input 类别）可定义项目的输入轴和游戏操作。

要添加更多输入轴，请增大 Size 属性中的值。

### 虚拟轴
每个项目在创建时都具有以下默认输入轴：
- Horizontal 和 Vertical 映射到 w、a、s、d 键和箭头键。
- Fire1、Fire2 和 Fire3 分别映射到 Control 键、Option (Alt) 键和 Command 键。
- Mouse X 和 Mouse Y 映射到鼠标移动的增量。
- Window Shake X 和 Window Shake Y 映射到窗口的移动。

每个输入轴提供以下属性列表：

|属性	|功能|
|----|----|
|Name	|输入指代游戏启动器中的轴并通过脚本引用的字符串。|
|Descriptive Name	|输入游戏启动器中显示的 Positive Button 功能的详细定义。|
|Descriptive Negative Name	|输入游戏启动器中显示的 Negative Button 功能的详细定义。|
|Negative Button	|输入向轴发送负值的按钮的名称。|
|Positive Button	|输入向轴发送正值的按钮的名称。|
|Alt Negative Button	|输入向轴发送负值的辅助按钮的名称。|
|Alt Positive Button	|输入向轴发送正值的辅助按钮的名称。|
|Gravity	|设置输入重新居中的速度。仅当 Type 设置为 key / mouse button 时，此属性才适用。|
|Dead	|任何小于此数字的正值或负值都视为零。适用于游戏杆。|
|Sensitivity	|对于键盘输入，值越大，响应越快。较小的值将更加平滑。对于鼠标增量，该值会缩放实际鼠标增量。|
|Snap	|启用此选项可在接收相反输入后立即将轴值重置为零。仅当 Type 设置为 key / mouse button 时，此属性才适用。|
|Invert	|启用此选项可使正值按钮向轴发送负值，反之亦然。|
|Type	|选择此轴期望的输入类型。|
|- _Key / Mouse Button_	|任何一种按钮。|
|- _Mouse Movement_	|鼠标增量和滚轮。|
|- _Window Movement_	|用户移动窗口。|
|- _Joystick Axis_	|模拟游戏杆|
|Axis|轴选择来自设备（游戏杆、鼠标、游戏手柄等）的输入轴。默认为 X 轴。|
|Joy Num	|选择应该使用哪个游戏杆。默认为从所有游戏杆检索输入。注意：这仅用于输入轴而不是按钮。|

**在 Input 设置中设置的所有轴都有两个用途**：
- 允许在脚本中按轴名称引用输入。若要使用输入来进行任何类型的**移动行为，请使用 Input.GetAxis**。 **请将 Input.GetButton 仅用于事件等操作。不要将它用于移动操作。**
- 允许游戏玩家根据自己的喜好自定义控制方式。

**轴的值介于 –1 到 1 之间。中性位置为 0**。 这是游戏杆输入和键盘输入的情况。

但是，Mouse Delta 和 Window Shake Delta 是鼠标或窗口在最后一帧中移动的程度。这意味着，**当用户快速移动鼠标时，它可以大于 1 或小于 –1**。

**可以使用相同的名称创建多个轴。获取输入轴时，将返回绝对值最大的轴**。这样就可以将多个输入设备分配给一个轴名称。例如，为键盘输入创建一个轴，用相同名称为游戏杆输入创建一个轴。如果用户正在使用游戏杆，则输入将来自游戏杆，否则输入将来自键盘。这样一来，不必在编写脚本时考虑输入的来源。

**键的名称遵循以下约定**：
- 普通键：“a”、“b”、“c”…
- 数字键：“1”、“2”、“3”…
- 箭头键：“up”、“down”、“left”和“right”
- 键盘键：“[1]”、“[2]”、“[3]”、“[+]”和“[equals]”
- 修饰键：“right shift”、“left shift”、“right ctrl”、“left ctrl”、“right alt”、“left alt”、“right cmd”、“left cmd”
- 鼠标按钮：“mouse 0”、“mouse 1”、“mouse 2”…
- 游戏杆按钮（任何游戏杆）：“joystick button 0”、“joystick button 1”、“joystick button 2”…
- 游戏杆按钮（特定游戏杆）：“joystick 1 button 0”、“joystick 1 button 1”、“joystick 2 button 0”…
- 特殊键：“backspace”、“tab”、“return”、“escape”、“space”、“delete”、“enter”、“insert”、“home”、“end”、“page up”和“page down”
- 功能键：“f1”、“f2”、“f3”…

请注意，执行 Update 前，不会重置 Input 标志。**建议在 Update 循环中进行所有的 Input 调用**。

**游戏启动器**提供所有已定义的轴，并显示每个轴的名称、详细描述和默认按钮。在此处，可以更改轴中定义的任何按钮。因此，最好使用轴（而不是单个按钮）来编写脚本，因为玩家可能希望自定义游戏按钮。

### KeyCode
Event.keyCode 返回的键代码。这些代码直接映射到键盘上的物理键。

键代码可以用于通过 Input.GetKeyDown 和 Input.GetKeyUp 检测键按下和键松开事件。

### 移动设备

iOS 和 Android 设备能够跟踪多根手指同时触摸屏幕的操作。 您可以通过访问 Input.touches 属性数组来访问最后一帧期间每根手指触摸屏幕的状态数据。

设备移动时，其加速度计硬件将报告设备沿三维空间中的三个主轴的线性加速度变化。 您可以使用该数据检测设备的当前方向（相对于地面）以及该方向上的任何即时更改。

硬件将沿每个轴的加速度直接报告为重力值。 值 1.0 表示沿给定轴约 +1g 的荷载，值 -1.0 表示 -1g。 当将设备竖直握住（主按钮位于底部）举到您正前方时， 右侧为正 X 轴，上方为正 Y 轴，指向您的方向为正 Z 轴。

您可以读取 Input.acceleration 属性来获取加速度计读数。 也可以使用 Input.deviceOrientation 属性获取设备在三维空间中的方向的离散估值。 如果您想在用户旋转设备（以不同方式把握设备时）时创建游戏行为，则检测方向变化将非常有用。

注意，每帧可以轮询加速度计硬件数次。 要访问自上一帧以来的所有加速度计样本，可以读取 Input.accelerationEvents 属性数组。 这在重建玩家动作、将加速度数据输入预测器或实现其他精确运动分析时非常有用。


世界空间与本地空间
-----

